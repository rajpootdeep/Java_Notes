------------------------------------------------------------------ Twelve-Factor Methodology ---------------------------------------------------------------------


The twelve-factor methodology is a set of twelve best practices to develop applications developed to run as a service


Codebase - Github

Dependencies - Gradle

Configurations

Backing Service - Database or Message Broker, to replace these, only configurations should be changes

Build, Release and Run  - converting code base into running application contains separate stages

Processes - stateless process

Port Binding

Concurrency

Disposability

Dev/Prod Parity  - keeping the gap between development and production environment as minimal as possible

Logs - it is a time-ordered stream of events.

Admin Processes - keeping such admin scripts together with the application codebase


-------------------------------------------------------------------Microservices --------------------------------------------------------------


Microservices are basically services are expose by REST in addition to that you have small deployable units and these should be cloud enabled.


Challenges in building Microservices :

Bounded Context  - what we should do and what not to do in a microservice
Configuration Management - 
Dynamic scale up and scale down - 


	Naming Server (Eureka) - all the intances of all microservices would register with naming server.
		
		Service registration - 
		Service discovery -

	 Ribbon ( Client side load balancing ) - it will make sure load is evenly distributed among the existing instances that it get from naming server.

	Feign (Easier REST Clients) - machanism to write simple RESTful clients
 
		





Visisbility and Monitoring -  


	Zipkin Distributed Tracing server , we will use Spring Cloud bus to assign a ID to a request accross multiple component, we use Zipkin to trace  a request across multiple components.

Lot of common features for example logging, security, analytics etc, we will not implements all these common features in every microservice, API gateways provide great solutions for these, we use for now Netflix ZULL API Gateway.

We will also  implements Fault Tolerence using Hitrix, if a service is down Hytrix help us to configure a default response .

	
	



Pack of cards -


SpringCloudConfigServer - it provides an approach where you can store all the configuration for the all the different environments of all the Microservices in a git repository 


Spring cloud config server - 8888
Netflix Eureka Naming server 8761
Netflix Zuul API Gateway 8765
Zipkin Distributed Tracing Server -9411
----------------------------------------------------------------------------------------------------------------------------------

@EnableConfigServer -: It will turn our application into a configuration server.
spring.application.name=config
spring.cloud.config.server.git.uri=file://${user.home}/application-config


Configure properties in each application that know how to talk back to config server is a bootstrap process
